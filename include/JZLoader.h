#ifndef __JZ_LOADER_H__
#define __JZ_LOADER_H__
#include <Windows.h>
#include <tchar.h>
#include <io.h>
// 最大字符串长度定义
#ifndef MAX_PATH
#	define MAX_PATH		260
#endif // !MAX_PATH

// 环境变量的缺省最大长度，如果系统环境变量长度大于该值时，可选择修改此值。
#ifndef JZENV_MAX_LENGTH
#	define JZENV_MAX_LENGTH	4096
#endif // !JZENV_MAX_LENGTH

//	库相对路径与库后缀名声明
#define JZ_DLL						_T("\\dll")
#define JZDLL_POSTFIX_DEBUG			_T("d.dll")
#define JZDLL_POSTFIX_RELEASE		_T(".dll")
#define JZDIR_SEPARATOR				_T('\\')
#define JZDIR_SEPARATOR_S			_T("\\")
#define JZENV_SEPARATOR				_T(';')
#define JZENV_SEPARATOR_S			_T(";")
#ifdef _DEBUG
#		ifdef _WIN64
#			define JZDLL_DIR		_T("\\x64\\Debug")
#		else
#			define JZDLL_DIR		_T("\\Win32\\Debug")
#		endif // _WIN64
#	else
#		ifdef _WIN64
#			define JZDLL_DIR		_T("\\x64\\Release")
#		else
#			define JZDLL_DIR		_T("\\Win32\\Release")
#		endif // _WIN64
#endif // _DEBUG

// dll释放函数
inline void JZDLL_Unload(HMODULE hDLL)
{
	if (NULL != hDLL)
	{
		FreeLibrary(hDLL);
		hDLL = NULL;
	}
}

// 加载库子函数
inline HMODULE _JZDLL_LoadLibrary(LPCTSTR szDLLName, // 动态库名，不包含扩展名 
								  LPCTSTR szPostfix) // 后缀名，包含了扩展名
{
	TCHAR s_name[MAX_PATH] = { 0 };
	s_name[0] = '\0';
	_tcscpy(s_name, szDLLName);
	_tcscat(s_name, szPostfix);
	return LoadLibrary(s_name);
}

typedef void* (*DefGetAPIStuPtr)();
// 获取API指针
inline void _JZDLL_GetAPI(HMODULE& hDLL,			// 已加载的库句柄
						  LPCSTR szAPIExportName,	// 加载库导出接口的名字
						  void** ppAPI)				// 输出功能组接口指针
{
	DefGetAPIStuPtr pfnGet = reinterpret_cast<DefGetAPIStuPtr>(GetProcAddress(hDLL, szAPIExportName));
	*ppAPI = pfnGet();
	if (NULL == *ppAPI)
	{
		JZDLL_Unload(hDLL);	// 如果导出接口不成功，则释放 DLL
		hDLL = NULL;
	}
}

// 将指定目录下的所有子目录设置为环境变量
inline void JZDLL_SetEnv(LPCTSTR szImportDLLPath)
{
	if (NULL == szImportDLLPath) // 当传入的路径为空时，自动寻找Import_dll目录
	{
		TCHAR s_top[MAX_PATH] = { 0 };
		s_top[0] = '\0';
		GetModuleFileName(NULL, s_top, MAX_PATH - 1);
		LPCTSTR p_separator = NULL;
		GetModuleFileName(NULL, s_top, MAX_PATH - 1);
		for (int i = 0; i < 4; i++)
		{
			p_separator = _tcsrchr(s_top, JZDIR_SEPARATOR);
			if (NULL == p_separator)
			{
				return ;
			}
			*(LPTSTR)p_separator = '\0';
		}
		_tcscat(s_top, JZDIR_SEPARATOR_S);
		_tcscat(s_top, _T("dll\\Import_dll\\"));
		szImportDLLPath = s_top;
	}
	
	// 获取环境变量
	TCHAR s_env[JZENV_MAX_LENGTH] = { 0 };
	s_env[0] = '\0';
	GetEnvironmentVariable(_T("Path"), s_env, JZENV_MAX_LENGTH - 1);
	_tcscat(s_env, JZENV_SEPARATOR_S);

	// 查找指定目录下的所有子目录
	TCHAR s_path[MAX_PATH] = { 0 };
	s_path[0] = '\0';
	_tfinddata_t info_file;
	intptr_t h_file;
	TCHAR s_search[MAX_PATH] = { 0 };
	s_search[0] = '\0';
	_tcscpy(s_search, szImportDLLPath);
	_tcscat(s_search, _T("*"));
	h_file = _tfindfirst(s_search, &info_file);
	if (-1 == h_file) // 如果没有搜索到文件和子文件夹
	{
		return;
	}
	else
	{
		// 如果查找的第一时文件夹则将其作添加到环境变量
		if (0 != (info_file.attrib & _A_SUBDIR)
			&& _tcscmp(info_file.name, _T("."))
			&& _tcscmp(info_file.name, _T("..")))
		{
			_tcscat(s_path, szImportDLLPath);
			_tcscat(s_path, info_file.name);
			_tcscat(s_path, JZDLL_DIR);
			_tcscat(s_path, JZENV_SEPARATOR_S);
			if (NULL == _tcsstr(s_env, s_path))
			{
				SetEnvironmentVariable(_T("Path"), s_path);
			}
			s_path[0] = '\0';
		}
		else // 如果找到的第一是文件，则忽略不管
		{	
		}

		// 查找剩下的文件夹或文件
		while (-1 != _tfindnext(h_file, &info_file))
		{
			if (0 != (info_file.attrib & _A_SUBDIR)
				&& _tcscmp(info_file.name, _T("."))
				&& _tcscmp(info_file.name, _T(".."))) // 如果找到了子文件夹则将其作为将要添加到环境变量的目录
			{
				_tcscat(s_path, szImportDLLPath);
				_tcscat(s_path, info_file.name);
				_tcscat(s_path, JZDLL_DIR);
				_tcscat(s_path, JZENV_SEPARATOR_S);
				if (NULL == _tcsstr(s_env, s_path))
				{
					SetEnvironmentVariable(_T("Path"), s_path);
				}
				s_path[0] = '\0';
			}
			else // 如果找到的是子文件，则忽略不管，继续往下查找
			{
			}
		}
		_findclose(h_file);
	}

	

}

// dll加载函数
inline HMODULE JZDLL_Load(
	LPCTSTR szDLLName,				// 加载库的名字
	LPCSTR szAPIExtName,			// 加载库导出接口的名字
	void** ppAPI)					// 输出功能组接口指针
{
	// 参数检查
	if (NULL == szDLLName || NULL == szAPIExtName)
	{
		return NULL;
	}

	JZDLL_SetEnv(NULL);// 将指定目录下的所有子目录设置为环境变量

	HMODULE hDLL = NULL;
	// 预先加载一次，避免重复的搜索缺省路径，尤其是单件加载器被多个库调用时
#ifdef _DEBUG
	hDLL = _JZDLL_LoadLibrary(szDLLName, JZDLL_POSTFIX_DEBUG); // 如果系统处于 DEBUG 模式下时，尝试导入 DEBUG 版本库
#endif // _DEBUG
	if (NULL == hDLL) // 如果不在 DEBUG 模式下或导入 DEBUG 版本库失败，则尝试导入 RELEASE 版本库
	{
		hDLL = _JZDLL_LoadLibrary(szDLLName, JZDLL_POSTFIX_RELEASE);
	}

	if (NULL != hDLL) // 如果加载成功则直接返回，否则继续执行下面代码进行搜索
	{
		_JZDLL_GetAPI(hDLL, szAPIExtName, ppAPI);
		return hDLL;
	}

	TCHAR s_top[MAX_PATH] = { 0 };
	TCHAR s_env[JZENV_MAX_LENGTH] = { 0 };
	s_top[0] = '\0';
	s_env[0] = '\0';

	TCHAR s_search[MAX_PATH] = { 0 };
	s_search[0] = '\0';


	LPCTSTR p_separator = NULL;
	GetModuleFileName(NULL, s_top, MAX_PATH - 1);
	for (int i = 0; i < 4; i++)
	{
		p_separator = _tcsrchr(s_top, JZDIR_SEPARATOR);
		if (NULL == p_separator)
		{
			return NULL;
		}
		*(LPTSTR)p_separator = '\0';
	}
	_tcscat(s_top, JZ_DLL);
	_tcscat(s_top, JZDLL_DIR);

	GetEnvironmentVariable(_T("Path"), s_env, JZENV_MAX_LENGTH - 1);
	_tcscat(s_env, JZENV_SEPARATOR_S);

	// 如果系统环境变量拥有当前环境变量则不再加入
	if (NULL == _tcsstr(s_env, s_top))
	{
		_tcscat(s_env, s_top);
	}
	SetEnvironmentVariable(_T("Path"), s_env);

#ifdef _DEBUG
	hDLL = _JZDLL_LoadLibrary(szDLLName, JZDLL_POSTFIX_DEBUG); // 如果系统处于 DEBUG 模式下时，尝试导入 DEBUG 版本库
#endif // _DEBUG
	if (NULL == hDLL) // 如果不在 DEBUG 模式下或导入 DEBUG 版本库失败，则尝试导入 RELEASE 版本库
	{
		hDLL = _JZDLL_LoadLibrary(szDLLName, JZDLL_POSTFIX_DEBUG);
	}

	_JZDLL_GetAPI(hDLL, szAPIExtName, ppAPI);
	return hDLL;
}

template<class _Func, class _Pos>
class JZLoader
{
public:
	JZLoader() throw() : _Moudle(NULL), _Fpval(NULL)
	{
		// 加载库，并获取接口指针
		Load(NULL);
	}

	~JZLoader() throw()
	{
		// 释放库
		if (NULL != _Moudle)
		{
			JZDLL_Unload(_Moudle);
		}
	}

	bool Load(LPCTSTR szDLLParentPath)
	{
		if (_IsLoaded())
		{
			return true;
		}
		else
		{
			_Pos _Pval;
			_Moudle = JZDLL_Load(_Pval.DLLName(), _Pval.APIExtName(), (void**)&_Fpval);
			return _IsLoaded();
		}	
	}

	// 重载本类型对象到bool的隐式转换
	operator bool() const
	{
		return (NULL != _Fpval);
	}

	operator _Func* ()
	{
		return _Fpval;
	}

	// 重载->指针运算符
	_Func* operator ->() const
	{
		return _Fpval;
	}

private:
	JZLoader(JZLoader<_Func, _Pos> const&) throw();
	JZLoader<_Func, _Pos>& operator=(JZLoader<_Func, _Pos> const&) throw();
	bool _IsLoaded()
	{
		return (NULL != _Moudle);
	}

private:
	HMODULE _Moudle;
	_Func* _Fpval;
};
#endif // __JZ_LOADER_H__

